using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

<# var typesArray = new[]{ "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }; #>
<# var types = new System.Collections.Generic.List<(string, int)>(); #>
<# var i = 0;
   foreach (var type in typesArray)
   {
       types.Add((type, i));
       i++;
   }#>
<# Func<(string, int), (string, int), string> casted = (a, b) => a.Item2 > b.Item2 ? a.Item1 : b.Item1; #>

public unsafe struct VariadicNumber
{
    private int index;

    private long value;

<# foreach (var (type, id) in types) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public VariadicNumber(<#= type #> value)
    {
        this.value = Unsafe.As<<#= type #>, long>(ref value);
        index = <#= id #>;
    }

    public static implicit operator VariadicNumber(<#= type #> value) => new(value);
<# } #>


<# foreach (var (op, opName) in new[] { ("+", "Add"), ("-", "Subtract"), ("*", "Multiply"), ("/", "Divide") }) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static VariadicNumber operator <#= op #>(VariadicNumber a, VariadicNumber b)
        => op<#= opName #>[a.index * 10 + b.index](a.value, b.value);
<# } #>

<# foreach (var (op, opName) in new[] { ("+", "Add"), ("-", "Subtract"), ("*", "Multiply"), ("/", "Divide") }) { #>
    private static readonly delegate*<long, long, VariadicNumber>[] op<#= opName #> = new delegate*<long, long, VariadicNumber>[]
    {
<# foreach (var (type1, id1) in types) { #>
<# foreach (var (type2, id2) in types) { #>
        &Op<#= opName #><#= type1 #><#= type2 #>,
<# } #>
<# } #>
    };
<# } #>

<# foreach (var (op, opName) in new[] { ("+", "Add"), ("-", "Subtract"), ("*", "Multiply"), ("/", "Divide") }) { #>

<# foreach (var (type1, id1) in types) { #>
<# foreach (var (type2, id2) in types) { #>
<# var cast = casted((type1, id1), (type2, id2)); #>
    private static VariadicNumber Op<#= opName #><#= type1 #><#= type2 #>(long left, long right)
        => new((<#= cast #>)((<#= cast #>)Unsafe.As<long, <#= type1 #>>(ref left) <#= op #> (<#= cast #>)Unsafe.As<long, <#= type2 #>>(ref right)));
<# } #>
<# } #>

<# } #>


    public override string ToString()
        => index switch
        {
<# foreach (var (type1, id1) in types) { #>
<# if (id1 == typesArray.Length - 1) { #>
            _ => Unsafe.As<long, <#= type1 #>>(ref value).ToString()
<# } else { #>
            <#= id1 #> => Unsafe.As<long, <#= type1 #>>(ref value).ToString(),
<# } #>
<# } #>
        };

    public string ToString(bool includeType)
        => !includeType ? ToString() :
        index switch
        {
<# foreach (var (type1, id1) in types) { #>
<# if (id1 == typesArray.Length - 1) { #>
            _ => "<#= type1 #>: " + Unsafe.As<long, <#= type1 #>>(ref value).ToString()
<# } else { #>
            <#= id1 #> => "<#= type1 #>: " + Unsafe.As<long, <#= type1 #>>(ref value).ToString(),
<# } #>
<# } #>
        };


    public static bool TryParse(string s, out VariadicNumber res)
    {
        res = default;
<# foreach (var (type, _) in types) { #>
        if (<#= type #>.TryParse(s, out var <#= type #>Value))
        {
            res = new(<#= type #>Value);
            return true;
        }
<# } #>
        return false;
    }

    public static VariadicNumber Parse(string s)
        => TryParse(s, out var res) ? res : throw new();
}
